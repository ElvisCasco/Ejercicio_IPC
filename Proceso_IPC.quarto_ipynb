{
  "cells": [
    {
      "cell_type": "markdown",
      "metadata": {},
      "source": [
        "---\n",
        "title: \"Proceso de Cálculo IPC desde Variedades\"\n",
        "author: \"Elvis Casco\"\n",
        "crossref:\n",
        "  fig-title: Gráfico     # (default is \"Figure\")\n",
        "  tbl-title: Tabla     # (default is \"Table\")\n",
        "  fig-prefix: Gráfico   # (default is \"Figure\")\n",
        "  tbl-prefix: Tabla    # (default is \"Table\")\n",
        "format:\n",
        "#   html:\n",
        "#     toc: true\n",
        "#     code-fold: true\n",
        "  pdf: \n",
        "    documentclass: report\n",
        "    # classoption: landscape\n",
        "    geometry:\n",
        "      - top=5mm\n",
        "      - left=10mm\n",
        "      - right=10mm\n",
        "    echo: false\n",
        "    warnings: false\n",
        "    keep-ipynb: true\n",
        "jupyter: python3\n",
        "---\n",
        "\n",
        "\n",
        "# Librerías y funciones\n",
        "\n",
        "## Librerías\n"
      ],
      "id": "6927efb7"
    },
    {
      "cell_type": "code",
      "metadata": {},
      "source": [
        "# %pip install --upgrade polars\n",
        "\n",
        "# import duckdb\n",
        "# import glob\n",
        "# import matplotlib.pyplot as plt\n",
        "import numpy as np\n",
        "# import os\n",
        "import polars as pl\n",
        "# import pandas as pd\n",
        "# import pyarrow\n",
        "# import reader\n",
        "# import time\n",
        "\n",
        "from great_tables import GT\n",
        "# from math import ceil\n",
        "# from multiprocessing import Pool\n",
        "# from typing import Dict, Any\n",
        "# from typing import Optional\n",
        "\n",
        "wd = \"C:/Directorio_Trabajo/2024/IPC_Calc/\""
      ],
      "id": "90a536e4",
      "execution_count": null,
      "outputs": []
    },
    {
      "cell_type": "markdown",
      "metadata": {},
      "source": [
        "## Funciones\n"
      ],
      "id": "5286c40e"
    },
    {
      "cell_type": "code",
      "metadata": {},
      "source": [
        "# DataFrame de ponderaciones por agrupación y región desde hoja de Excel\n",
        "def get_ponds_from_xlsx():\n",
        "    df = pl.read_excel(\n",
        "        source = wd + \"Categorias.xlsx\",\n",
        "        sheet_name = \"Regiones\",\n",
        "        infer_schema_length=None,\n",
        "        schema_overrides={\n",
        "            \"División\": pl.String,\n",
        "            \"Grupo\": pl.String,\n",
        "            \"Clase\": pl.String,\n",
        "            \"SubClase\": pl.String,\n",
        "            \"Categoría\": pl.String,\n",
        "            \"Producto\": pl.String,\n",
        "            },\n",
        "    )[:,1:]\n",
        "    df = df.with_columns(\n",
        "        pl.col(\"Código\").str.slice(0, 2).alias(\"División\"),\n",
        "        pl.col(\"Código\").str.slice(0, 3).alias(\"Grupo\"),\n",
        "        pl.col(\"Código\").str.slice(0, 4).alias(\"Clase\"),\n",
        "        pl.col(\"Código\").str.slice(0, 5).alias(\"SubClase\"),\n",
        "        pl.col(\"Código\").str.slice(0, 6).alias(\"Categoría\"),\n",
        "        pl.col(\"Código\").str.slice(0, 8).alias(\"Producto\"),\n",
        "        )\n",
        "    return df\n",
        "\n",
        "# DataFrame de índices desde hoja de Excel\n",
        "def get_df_from_xlsx(region):\n",
        "    df = pl.read_excel(\n",
        "        source = wd + \"Ejercicio calculo IPC - Investigación.xlsx\",\n",
        "        sheet_name = region\n",
        "    )[:,2:]\n",
        "    return df\n",
        "\n",
        "# Solo los datos que contienen Precio, Unidad de Medida o Contenido; depura establecimientos\n",
        "def get_valid_columns_in_df(df):\n",
        "    nombres_t = df.columns\n",
        "    df[1,0]=\"Precio\"\n",
        "    df[1,1]=\"Unidad de Medida\"\n",
        "    df[1,2]=\"Contenido\"\n",
        "\n",
        "    check_list=[\"Precio\",\"Unidad de Medida\",\"Contenido\"] \n",
        "    row_values = df.row(1)\n",
        "    conditions_met = [value in check_list for value in row_values]\n",
        "    df = df[conditions_met]\n",
        "    return df\n",
        "\n",
        "# Repetir los valores de los establecimientos en la primera fila\n",
        "def repeat_names_in_row(row):\n",
        "    row = list(row)\n",
        "    for i in range(1, len(row)):\n",
        "        if i % 3 != 0:\n",
        "            row[i] = row[i - (i % 3)]\n",
        "    return row\n",
        "\n",
        "def replace_names_in_df(df,row_index,modified_row):\n",
        "    row_values = df.row(row_index)\n",
        "    df = df.with_columns([\n",
        "        pl.when(\n",
        "            pl.arange(0, df.height) == row_index\n",
        "            ).then(\n",
        "                pl.lit(modified_row[i])\n",
        "            ).otherwise(pl.col(col)\n",
        "            ).alias(col)\n",
        "        for i, col in enumerate(df.columns)\n",
        "    ])\n",
        "    return df\n",
        "\n",
        "def modify_df_names(df):\n",
        "    modified_row = repeat_names_in_row(df.row(0))\n",
        "    df = replace_names_in_df(df,0,modified_row)\n",
        "    return df\n",
        "\n",
        "def replace_unnamed(row):\n",
        "    for i in range(1, len(row)):\n",
        "        if r\"UNNAMED\" in row[i]:\n",
        "            row[i] = row[i - 1]\n",
        "    return row\n",
        "\n",
        "def modify_df_establecimientos(df):\n",
        "    modified_row = df.columns\n",
        "    df = replace_names_in_df(df,2,modified_row)\n",
        "    row_index = 2\n",
        "    row_values = df.row(row_index)\n",
        "    modified_row = replace_unnamed(list(row_values))\n",
        "    df = replace_names_in_df(df,2,modified_row)\n",
        "    return df\n",
        "\n",
        "def obtener_dataframe(region):\n",
        "    df = get_df_from_xlsx(region)\n",
        "    df = get_valid_columns_in_df(df)\n",
        "    df = modify_df_names(df)\n",
        "    df = modify_df_establecimientos(df)\n",
        "    df[0,1] = \".\"\n",
        "    a_list = [\"Unidad de Medida\",\"Codigo\",'.']\n",
        "    df = df.filter(\n",
        "        pl.col('Codigo').str.contains_any(a_list))\n",
        "    indices_to_select = [1] + list(range(3, len(df.columns)))\n",
        "    columns_to_select = [df.columns[i] for i in indices_to_select]\n",
        "    df = df.select(columns_to_select)\n",
        "    df = df.transpose(include_header=False)\n",
        "    new_column_names_row = df.row(0)\n",
        "    new_column_names = list(new_column_names_row)\n",
        "    rename_dict = {\n",
        "        old: new for old, new in zip(df.columns, new_column_names)}\n",
        "    df = df.rename(rename_dict)\n",
        "    df = df[1:,:]\n",
        "    return df\n",
        "\n",
        "def obtener_precio_t_1(region):\n",
        "    df = obtener_dataframe(region)\n",
        "    df_Precio_t_1 = df.filter(\n",
        "        pl.col('Codigo').str.contains('t-1'))\n",
        "    df_Precio_t_1 = df_Precio_t_1.filter(\n",
        "        pl.col('Unidad de Medida').str.contains('Precio'))\n",
        "    df_Precio_t_1.write_excel(\n",
        "        workbook = wd + region + \"/\" + region + \"_Precio_t_1.xlsx\")\n",
        "    word = ' Precio'\n",
        "    pattern = f'{word}.*'\n",
        "    df_Precio_t_1 = df_Precio_t_1.with_columns(\n",
        "        pl.col('Codigo').str.replace(pattern,\"\"))\n",
        "    word = ' Precio'\n",
        "    pattern = f'{word}.*'\n",
        "    df_Precio_t_1 = df_Precio_t_1.with_columns(\n",
        "        pl.col('Codigo').str.replace(pattern,\"\"))\n",
        "    return df_Precio_t_1\n",
        "\n",
        "def obtener_contenido_t_1(region):\n",
        "    df = obtener_dataframe(region)\n",
        "    df_Contenido_t_1 = df.filter(\n",
        "        pl.col('Codigo').str.contains('t-1'))\n",
        "    df_Contenido_t_1 = df_Contenido_t_1.filter(\n",
        "        pl.col('Unidad de Medida').str.contains('Contenido'))\n",
        "    df_Contenido_t_1.write_excel(\n",
        "        workbook = wd + region + \"/\" + region + \"_Contenido_t_1.xlsx\")\n",
        "    word = ' Precio'\n",
        "    pattern = f'{word}.*'\n",
        "    df_Contenido_t_1 = df_Contenido_t_1.with_columns(\n",
        "        pl.col('Codigo').str.replace(pattern,\"\"))\n",
        "    word = ' Precio'\n",
        "    pattern = f'{word}.*'\n",
        "    df_Contenido_t_1 = df_Contenido_t_1.with_columns(\n",
        "        pl.col('Codigo').str.replace(pattern,\"\"))\n",
        "    return df_Contenido_t_1\n",
        "\n",
        "def obtener_precio_t(region):\n",
        "    df = obtener_dataframe(region)\n",
        "    df_Precio_t = df.filter(\n",
        "        ~pl.col('Codigo').str.contains('t-1'))\n",
        "    df_Precio_t = df_Precio_t.filter(\n",
        "        pl.col('Unidad de Medida').str.contains('Precio'))\n",
        "    df_Precio_t.write_excel(workbook = wd + region + \"/\" + region + \"_Precio_t.xlsx\")\n",
        "    word = ' Precio'\n",
        "    pattern = f'{word}.*'\n",
        "    df_Precio_t = df_Precio_t.with_columns(\n",
        "        pl.col('Codigo').str.replace(pattern,\"\"))\n",
        "    return df_Precio_t\n",
        "\n",
        "def obtener_contenido_t(region):\n",
        "    df = obtener_dataframe(region)\n",
        "    df_Contenido_t = df.filter(\n",
        "        ~pl.col('Codigo').str.contains('t-1'))\n",
        "    df_Contenido_t = df_Contenido_t.filter(\n",
        "        pl.col('Unidad de Medida').str.contains('Contenido'))\n",
        "    df_Contenido_t.write_excel(workbook = wd + region + \"/\" + region + \"_Contenido_t.xlsx\")\n",
        "    word = ' Precio'\n",
        "    pattern = f'{word}.*'\n",
        "    df_Contenido_t = df_Contenido_t.with_columns(\n",
        "        pl.col('Codigo').str.replace(pattern,\"\"))\n",
        "    return df_Contenido_t"
      ],
      "id": "9c8d2f04",
      "execution_count": null,
      "outputs": []
    },
    {
      "cell_type": "code",
      "metadata": {},
      "source": [
        "def obtener_indices(wd,region):\n",
        "    # Valores en t\n",
        "    p_t = obtener_precio_t(region)\n",
        "    my_columns = p_t.columns\n",
        "    cols_to_process = my_columns[3:p_t.shape[1]]\n",
        "    p_t[cols_to_process] = p_t[cols_to_process].cast(pl.Float64, strict=False)\n",
        "    c_t = obtener_contenido_t(region)\n",
        "    my_columns = c_t.columns\n",
        "    cols_to_process = my_columns[3:c_t.shape[1]]\n",
        "    c_t[cols_to_process] = c_t[cols_to_process].cast(pl.Float64, strict=False)\n",
        "\n",
        "    # Valores en t-1\n",
        "    p_t_1 = obtener_precio_t_1(region)\n",
        "    my_columns = p_t_1.columns\n",
        "    cols_to_process = my_columns[3:p_t_1.shape[1]]\n",
        "    p_t_1[cols_to_process] = p_t_1[cols_to_process].cast(pl.Float64, strict=False)\n",
        "    c_t_1 = obtener_contenido_t_1(region)\n",
        "    my_columns = c_t_1.columns\n",
        "    cols_to_process = my_columns[3:c_t_1.shape[1]]\n",
        "    c_t_1[cols_to_process] = c_t_1[cols_to_process].cast(pl.Float64, strict=False)\n",
        "\n",
        "    # Índice de Precios por Establecimiento y Variedad\n",
        "    i_t = p_t.clone()\n",
        "    i_t[my_columns[3:i_t.shape[1]]] = (p_t[my_columns[3:c_t.shape[1]]] / c_t[my_columns[3:c_t.shape[1]]]) / (p_t_1[my_columns[3:c_t_1.shape[1]]] / c_t_1[my_columns[3:c_t_1.shape[1]]])\n",
        "    i_t = i_t.with_columns(pl.lit(region).alias(\"Región\"))\n",
        "    i_t.write_excel(\n",
        "        workbook = wd + region + \"/\" + region + \"_Establecimiento.xlsx\")\n",
        "\n",
        "    # Índice de Precios por Variedad: Media Geométrica\n",
        "    res_variedad = pl.DataFrame([\n",
        "        pl.Series(\"Variedad\", my_columns[3:i_t.shape[1]], dtype=pl.String)])\n",
        "    res_variedad = res_variedad.with_columns(pl.col(\"Variedad\").str.slice(0, 8).alias(\"Producto\"))\n",
        "    res_variedad = res_variedad.with_columns(\n",
        "        Indice = 0.0)\n",
        "    for row in range(res_variedad.shape[0]):\n",
        "        res_variedad[row,2] = geometric_mean(\n",
        "            i_t[res_variedad[\"Variedad\"][row]].drop_nans() * 100)\n",
        "    res_variedad = res_variedad.with_columns(pl.lit(region).alias(\"Región\"))\n",
        "    res_variedad.write_excel(\n",
        "        workbook = wd + region + \"/\" + region + \"_Variedad.xlsx\")\n",
        "\n",
        "    # Índice de Precios por Producto: Media Geométrica\n",
        "    res_producto = (\n",
        "        res_variedad.group_by(\"Producto\", maintain_order=True)\n",
        "        .agg(\n",
        "            pl.map_groups(\n",
        "                exprs=[\"Indice\"],\n",
        "                function=geometric_mean)\n",
        "        ))\n",
        "    res_producto = res_producto.join(\n",
        "        ponderaciones_producto_region, \n",
        "        on=\"Producto\")\n",
        "    res_producto = res_producto.with_columns(\n",
        "        (pl.col(\"Indice\") * pl.col(region) / 100).alias(\"Indice_Pond\"),)\n",
        "    res_producto = res_producto.with_columns(pl.lit(region).alias(\"Región\"))\n",
        "    res_producto[\n",
        "        \"Producto\",\"Indice\",region,\"Indice_Pond\"].write_excel(\n",
        "        workbook = wd + region + \"/\" + region + \"_Producto.xlsx\")\n",
        "\n",
        "    ## Índice de Precios por Agrupaciones: Media Ponderada\n",
        "    grupo = \"Categoría\"\n",
        "    res_categoria = weighted_index_group_region(res_producto,grupo)\n",
        "    res_categoria = res_categoria.with_columns(pl.lit(region).alias(\"Región\"))\n",
        "    res_categoria.write_excel(\n",
        "        workbook = wd + region +\"/\" + region + \"_\" + grupo + \".xlsx\")\n",
        "    grupo = \"SubClase\"\n",
        "    res_subclase = weighted_index_group_region(res_producto,grupo)\n",
        "    res_subclase = res_subclase.with_columns(pl.lit(region).alias(\"Región\"))\n",
        "    res_subclase.write_excel(\n",
        "        workbook = wd + region +\"/\" + region + \"_\" + grupo + \".xlsx\")\n",
        "    grupo = \"Clase\"\n",
        "    res_subclase = weighted_index_group_region(res_producto,grupo)\n",
        "    res_subclase = res_subclase.with_columns(pl.lit(region).alias(\"Región\"))\n",
        "    res_subclase.write_excel(\n",
        "        workbook = wd + region +\"/\" + region + \"_\" + grupo + \".xlsx\")\n",
        "    grupo = \"Grupo\"\n",
        "    res_grupo = weighted_index_group_region(res_producto,grupo)\n",
        "    res_grupo = res_grupo.with_columns(pl.lit(region).alias(\"Región\"))\n",
        "    res_grupo.write_excel(\n",
        "        workbook = wd + region +\"/\" + region + \"_\" + grupo + \".xlsx\")\n",
        "    grupo = \"División\"\n",
        "    res_division = weighted_index_group_region(res_producto,grupo)\n",
        "    res_division = res_division.with_columns(pl.lit(region).alias(\"Región\"))\n",
        "    res_division.write_excel(\n",
        "        workbook = wd + region +\"/\" + region + \"_\" + grupo + \".xlsx\")\n",
        "\n",
        "    # Resultados en DataFrames\n",
        "    return p_t, c_t, p_t_1, c_t_1, i_t, res_variedad, res_producto, res_categoria, res_subclase, res_grupo, res_division\n",
        "\n",
        "# Function to calculate geometric mean\n",
        "def geometric_mean(series):\n",
        "    return np.exp(np.log(series).mean())\n",
        "\n",
        "def weighted_index_group_region(df,grupo):\n",
        "    result = df.group_by(grupo).agg(\n",
        "        [\n",
        "            (pl.col(\"Indice\") * pl.col(region) / 100).sum(\n",
        "            ).alias(\"weighted_sum\"),\n",
        "            pl.col(region).sum(\n",
        "            ).alias(\"Peso_\" + grupo)\n",
        "        ]).with_columns([\n",
        "            (pl.col(\"weighted_sum\") / pl.col(\"Peso_\" + grupo) * 100\n",
        "            ).alias(\"Índice_\" + grupo)\n",
        "        ]).select([grupo, \"Peso_\" + grupo, \"Índice_\" + grupo\n",
        "        ]).sort(grupo)\n",
        "    result = result.with_columns(\n",
        "        (pl.col(\"Índice_\" + grupo) * pl.col(\"Peso_\" + grupo) / 100).alias(\"Indice_Pond\"),\n",
        "    )\n",
        "    return result"
      ],
      "id": "7abeddde",
      "execution_count": null,
      "outputs": []
    },
    {
      "cell_type": "markdown",
      "metadata": {},
      "source": [
        "# Índices por Regiones\n",
        "\n",
        "- MDC = Metropolitana Distrito Central\n",
        "- RUC = Resto Urbano Central\n",
        "- MSPS =  Metropolitana San Pedro Sula\n",
        "- RUN = Resto Urbano Norte\n",
        "- ULA = Urbana Litoral Atlántico\n",
        "- UOri = Urbana Oriental\n",
        "- UOcc = Urbana Occidental\n",
        "- US = Urbana Sur\n",
        "\n",
        "## Ponderaciones\n",
        "\n",
        "Para obtener el IPC, se tienen ponderaciones por producto, para cada region:\n"
      ],
      "id": "e8bcd9ce"
    },
    {
      "cell_type": "code",
      "metadata": {},
      "source": [
        "regions = [\"MDC\",\"RUC\",\"MSPS\",\"RUN\",\"ULA\",\"UOri\",\"UOcc\",\"US\"]\n",
        "ponderaciones_producto_region = get_ponds_from_xlsx()\n",
        "GT(ponderaciones_producto_region[0:5,:]\n",
        "    ).fmt_number(columns=regions, decimals=4)"
      ],
      "id": "58494863",
      "execution_count": null,
      "outputs": []
    },
    {
      "cell_type": "markdown",
      "metadata": {},
      "source": [
        "Se agregó en el archivo de Excel, además de las ponderaciones por region y producto (columnas), lo siguiente:\n",
        "\n",
        "- Código: correspondiente al código de la Clasificación Individual de Consumo por Finalidades (CCIF);\n",
        "- CCIF: nombre del producto;\n",
        "- División: los primeros dos dígitos del Código;\n",
        "- Grupo: los primeros tres dígitos del Código;\n",
        "- Clase: los primeros cuatro dígitos del Código;\n",
        "- SubClase: los primeros cinco dígitos del Código;\n",
        "- Categoría: los primeros seis dígitos del Código;\n",
        "- Producto: correspondiente al CCIF.\n",
        "\n",
        "## Cálculos por Región\n",
        "\n",
        "Se realizan mediante una función, que agrega archivos a las carpetas nombradas con las siglas señaladas por region. \n",
        "\n",
        "La función crea dataframes que podrían utilizarse para visualizar los cálculos contenidos en los archivos; los nombres de los dataframes y archivos generados (incluyendo la sigla inicial de la region) son los siguientes:\n",
        "\n",
        "Cada archivo tiene un nombre que inicia también con las siglas de la región correspondiente. \n",
        "\n",
        "Para detallar cada dataframe y archivo de Excel resultante, se usará como ejemplo los resultados de la region MDC:\n"
      ],
      "id": "3072fcfb"
    },
    {
      "cell_type": "code",
      "metadata": {},
      "source": [
        "region = \"MDC\"\n",
        "p_t, c_t, p_t_1, c_t_1, i_t, res_variedad, res_producto, res_categoria, res_subclase, res_grupo, res_division = obtener_indices(wd,region)"
      ],
      "id": "c7ed0cc8",
      "execution_count": null,
      "outputs": []
    },
    {
      "cell_type": "markdown",
      "metadata": {},
      "source": [
        "### 1. Precios y Contenido en t, t-1\n",
        "\n",
        "- p_t, p_t_1, region_Precio_t.xlsx, region_Precio_t_1.xlsx = precios en t y t-1, por establecimiento y variedad\n"
      ],
      "id": "3e7d7350"
    },
    {
      "cell_type": "code",
      "metadata": {},
      "source": [
        "GT(p_t[0:5,0:5])"
      ],
      "id": "eb3ddf60",
      "execution_count": null,
      "outputs": []
    },
    {
      "cell_type": "code",
      "metadata": {},
      "source": [
        "GT(p_t_1[0:5,0:5])"
      ],
      "id": "5fac1984",
      "execution_count": null,
      "outputs": []
    },
    {
      "cell_type": "markdown",
      "metadata": {},
      "source": [
        "- c_t, c_t_1, region_Contenido_t.xlsx, region_Contenido_t_1.xlsx = contenido (en unidades de medida correspondientes a cada producto) en t y t-1, por establecimiento y variedad. Para el cálculo de los índices, el contenido corresponde a las cantidades, descritas en el \"Manual del índice de precios al consumidor\".\n"
      ],
      "id": "7c06e3f4"
    },
    {
      "cell_type": "code",
      "metadata": {},
      "source": [
        "GT(c_t[0:5,0:5])"
      ],
      "id": "5833f916",
      "execution_count": null,
      "outputs": []
    },
    {
      "cell_type": "code",
      "metadata": {},
      "source": [
        "GT(c_t_1[0:5,0:5])"
      ],
      "id": "0805978e",
      "execution_count": null,
      "outputs": []
    },
    {
      "cell_type": "markdown",
      "metadata": {},
      "source": [
        "### 2. Índice de Precios por Establecimiento y Variedad\n",
        "\n",
        "En el manual (capítulo 9), a este ítem se le llama \"producto muestreado\"\n",
        "\n",
        "- i_{e_v} = índice de precios unitario (por unidad de medida), por establecimiento y variedad.\n",
        "\n",
        "Sea $n$ la cantidad de productos en una canasta con precios $p_i$ y cantidades $q_i$, y sean 0 y $t$ los dos períodos que se comparan. \n",
        "\n",
        "El índice de Lowe $P_{Lo}$ para el producto $i$ de la región $r$ se define de la siguiente manera:\n",
        "\n",
        "$P_{Lo}=\\frac{\\sum_{i=1}^n p_i^t q_i}{\\sum_{i=1}^n p_0^t q_i}$\n",
        "\n",
        "$i_{ev}^r = \\frac{\\frac{p_{ev,t}^r}{c_{ev,t}^r}}{\\frac{p_{ev,t-1}^r}{c_{ev,t-1}^r}}$\n"
      ],
      "id": "6715df0f"
    },
    {
      "cell_type": "code",
      "metadata": {},
      "source": [
        "GT(i_t[0:5,0:5])"
      ],
      "id": "502034ed",
      "execution_count": null,
      "outputs": []
    },
    {
      "cell_type": "markdown",
      "metadata": {},
      "source": [
        "### 3. Índice de Precios por Variedad: Media Geométrica\n",
        "\n",
        "Como en la tabla mostrada anteriormente, cada columna corresponde a los índices por variedad, el índice a calcular es la media geométrica por columna:\n",
        "\n",
        "$i_V^r = \\sqrt[n]{{i_{ev_1}^r,i_{ev_2}^r,...,i_{ev_n}^r}} \\text{ for v in } V^r$\n",
        "\n",
        "$i_V^r = \\exp (\\frac{{\\ln i_{ev_1}^r + \\ln i_{ev_2}^r +...+\\ln i_{ev_n}^r}}{n}) \\text{ for v in } V^r$\n",
        "\n",
        "Los resultados se guardan de manera que cada fila coresponde al índice calculado por variedad.\n"
      ],
      "id": "48add909"
    },
    {
      "cell_type": "code",
      "metadata": {},
      "source": [
        "GT(res_variedad[0:5,:])"
      ],
      "id": "767dad74",
      "execution_count": null,
      "outputs": []
    },
    {
      "cell_type": "markdown",
      "metadata": {},
      "source": [
        "### 4. Índice de Precios por Producto (X): Media Geométrica\n",
        "\n",
        "$i_X^r = \\sqrt[n]{{i_{V_1}^r,i_{V_2}^r,...,i_{V_n}^r}} \\text{ for V in } X^r$\n",
        "\n",
        "$i_X^r = \\exp (\\frac{{\\ln i_{V_1}^r + \\ln i_{V_2}^r +...+\\ln i_{V_n}^r}}{n}) \\text{ for V in } X^r$\n"
      ],
      "id": "48266526"
    },
    {
      "cell_type": "code",
      "metadata": {},
      "source": [
        "GT(res_producto[0:5,[\"Producto\",\"Indice\",region,\"Indice_Pond\"]])"
      ],
      "id": "696d6dca",
      "execution_count": null,
      "outputs": []
    },
    {
      "cell_type": "markdown",
      "metadata": {},
      "source": [
        "En vista que cada producto tiene una ponderación diferente por región (w_R), se calcula una columna que contiene el índice ponderado por producto:\n",
        "\n",
        "$Indice\\_Pond^r$ = $i_X^r * w_X^r$\n",
        "\n",
        "La suma de esta columna corresponde al índice de precios al consumidor de la región:\n",
        "\n",
        "$IPC^r$ = $\\sum{Indice\\_Pond^r}$\n"
      ],
      "id": "68c40cd9"
    },
    {
      "cell_type": "code",
      "metadata": {},
      "source": [
        "# print(res_producto[region].sum())\n",
        "print(res_producto[\"Indice_Pond\"].sum())"
      ],
      "id": "3b5c6cc9",
      "execution_count": null,
      "outputs": []
    },
    {
      "cell_type": "markdown",
      "metadata": {},
      "source": [
        "### 5. Índice de Precios por Agrupaciones (A): Media Ponderada\n",
        "\n",
        "El peso de cada agrupación dentro del IPC regional corresponde a la suma de los pesos regionales de los productos correspondientes a dicha agrupación:\n",
        "\n",
        "$w_A^r = \\frac{w_X^r}{\\sum w_X^r} \\text{ for X in } A^r$\n",
        "\n",
        "El índice por agrupación es igual a:\n",
        "\n",
        "$i_A^r = \\sum i_X^r * \\frac{w_X^r}{w_A^r} \\text{ for X in } A^r$\n",
        "\n",
        "Al igual que en los índices por producto, se agrega la columna Indice_Pond:\n",
        "\n",
        "$Indice\\_Pond^r$ = $i_A^r * w_A^r$\n",
        "\n",
        "La suma de esta columna corresponde al índice de precios al consumidor de la región:\n",
        "\n",
        "$IPC^r$ = $\\sum{Indice\\_Pond^r}$\n",
        "\n",
        "#### Categoría\n"
      ],
      "id": "ac1373fd"
    },
    {
      "cell_type": "code",
      "metadata": {},
      "source": [
        "print(res_categoria[\"Indice_Pond\"].sum())\n",
        "GT(res_categoria[0:5,:])"
      ],
      "id": "cfe8c7ad",
      "execution_count": null,
      "outputs": []
    },
    {
      "cell_type": "markdown",
      "metadata": {},
      "source": [
        "#### SubClase\n"
      ],
      "id": "3c58953b"
    },
    {
      "cell_type": "code",
      "metadata": {},
      "source": [
        "print(res_subclase[\"Indice_Pond\"].sum())\n",
        "GT(res_subclase[0:10,:])"
      ],
      "id": "ec00f8f5",
      "execution_count": null,
      "outputs": []
    },
    {
      "cell_type": "markdown",
      "metadata": {},
      "source": [
        "#### Grupo\n"
      ],
      "id": "d6a6c125"
    },
    {
      "cell_type": "code",
      "metadata": {},
      "source": [
        "print(res_grupo[\"Indice_Pond\"].sum())\n",
        "GT(res_grupo)"
      ],
      "id": "78d9f671",
      "execution_count": null,
      "outputs": []
    },
    {
      "cell_type": "markdown",
      "metadata": {},
      "source": [
        "#### División\n"
      ],
      "id": "f1ccb2c1"
    },
    {
      "cell_type": "code",
      "metadata": {},
      "source": [
        "print(res_division[\"Indice_Pond\"].sum())\n",
        "GT(res_division)"
      ],
      "id": "79de2747",
      "execution_count": null,
      "outputs": []
    },
    {
      "cell_type": "markdown",
      "metadata": {},
      "source": [
        "# IPC, Ponderado\n",
        "\n",
        "Teniendo calculado el índice de precios por región, el IPC agregado se obtiene asignando una ponderación los índices para cada region:\n"
      ],
      "id": "aaf9db37"
    },
    {
      "cell_type": "code",
      "metadata": {},
      "source": [
        "ponderaciones_region = pl.read_excel(\n",
        "    source = wd + \"Categorias.xlsx\",\n",
        "    sheet_name = \"regions\",\n",
        "    infer_schema_length=None,)\n",
        "\n",
        "# Para ejecutar todas las regions:\n",
        "regions = [\"MDC\",\"RUC\",\"MSPS\",\"RUN\",\"ULA\",\"UOri\",\"UOcc\",\"US\"]\n",
        "for i, region in enumerate(regions):\n",
        "    res = obtener_indices(wd,region)\n",
        "    ponderaciones_region[i,3] = res[10][\"Indice_Pond\"].sum()\n",
        "GT(ponderaciones_region)"
      ],
      "id": "6eaa9268",
      "execution_count": null,
      "outputs": []
    },
    {
      "cell_type": "markdown",
      "metadata": {},
      "source": [
        "El proceso se tarda aproximadamente dos minutos.\n"
      ],
      "id": "be587620"
    },
    {
      "cell_type": "code",
      "metadata": {},
      "source": [
        "ipc = sum(ponderaciones_region[\"Ponderación\"] * ponderaciones_region[\"Índice Periodo t\"])\n",
        "print(\"IPC General =\" +  str(ipc))"
      ],
      "id": "9880291e",
      "execution_count": null,
      "outputs": []
    }
  ],
  "metadata": {
    "kernelspec": {
      "name": "python3",
      "language": "python",
      "display_name": "Python 3 (ipykernel)",
      "path": "C:\\Users\\ec109004\\AppData\\Roaming\\Python\\share\\jupyter\\kernels\\python3"
    }
  },
  "nbformat": 4,
  "nbformat_minor": 5
}